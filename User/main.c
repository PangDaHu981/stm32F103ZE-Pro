#include "main.h"
#include "AT24C02.h"
#include "Board_Flash.h"
#include "Task_LED.h"
#include "W25Q64.h"
#include "boot.h"
#include "delay.h"
#include "iic.h"
#include "stm32F10x.h"
#include "usart.h"

OTA_InfoCB OTA_Info;            // 保存在24C02内的OTA信息相关的结构体
UpdateA_CB UpdateA;             // A区更新用到的结构体
u32        BootStateFlag = 0;   // 记录全局状态标志位，每位表示1种状态

int main(void) {
    uint8_t i;
    LedGpioInit();       // LED引脚初始化
    delay_Init();        // 延时初始化
    USART1_Init(9600);   // 串口1初始化
    u1_printf("\r\n串口1初始化成功\r\n");
    IIC_Init();              // IIC初始化
    W25Q64_Init();           // W25Q64初始化
    
    AT24C02_ReadOTAInfo();   // 从24C02读取数据到OTA_Info结构体
    BootLoader_Branch();     // 分支判断
    while (1) {
        LED_Task();
        delay_ms(10);
        // 串口1接收
        if (U1_CB.URxDataOUT != U1_CB.URxDataIN) {                                                                      // 检查串口接收缓冲区是否有新数据
            Bootloader_Event_Process(U1_CB.URxDataOUT->start, (U1_CB.URxDataOUT->end - U1_CB.URxDataOUT->start + 1));   // 根据新数据处理对应任务
            U1_CB.URxDataOUT++;                                                                                         // 读指针后移
            if (U1_CB.URxDataOUT == U1_CB.URxDataEND) {
                U1_CB.URxDataOUT = &U1_CB.URxDataPtr[0];   // 如果已经到缓冲末尾，则重新回到缓冲区头部
            }
        }
        /*发送C*/
        if (BootStateFlag & IAP_XModem_C_FLAG) {   // 串口发送XModem协议的起始C
            if (UpdateA.XModem_Timer_Count >= 100) {
                u1_printf("C");
                UpdateA.XModem_Timer_Count = 0;
            }
            UpdateA.XModem_Timer_Count++;
        }
        /*处理W25Q64数据搬运stm32 flash*/
        // 这之前应该已经把APP代码存放到W25Q64中了
        /*--------------------------------------------------*/
        /*        UPDATA_A_FLAG置位，表明需要更新A区        */
        /*--------------------------------------------------*/
        if (BootStateFlag & UPDATA_A_FLAG) {
            u1_printf("本次需要更新的大小：%d字节\r\n", OTA_Info.FirmwareLen[UpdateA.Updata_A_from_W25Q64_Num]);
            if ((OTA_Info.FirmwareLen[UpdateA.Updata_A_from_W25Q64_Num] % 4) == 0) {   // 判断长度是否是4字节（32位）的整数倍，是的话则允许写入，进入if
                STM32_EraseFlash(STM32_A_START_PAGE, STM32_A_PAGE_NUM);                // 将A区空间擦除
                u1_printf("A区已擦除\r\n");
                /* 从W25Q64中读取1k并写入片上Flash */
                for (i = 0; i < (OTA_Info.FirmwareLen[UpdateA.Updata_A_from_W25Q64_Num] / STM32_PAGE_SIZE); i++) {                             // 先写完整的1k字节
                    W25Q64_Read(UpdateA.Updata_A_Buff, i * STM32_PAGE_SIZE + 64 * 1024 * UpdateA.Updata_A_from_W25Q64_Num, STM32_PAGE_SIZE);   // 读取到1k内容

                    STM32_WriteFlash(STM32_A_START_ADDR + i * STM32_PAGE_SIZE, (u32*) UpdateA.Updata_A_Buff, STM32_PAGE_SIZE);   // 将A区写入片上Flash位置
                }
                // 现在写完了前面完整的几k内容，下面写不到1k的内容
                if ((OTA_Info.FirmwareLen[UpdateA.Updata_A_from_W25Q64_Num] % 1024) != 0) {
                    memset(UpdateA.Updata_A_Buff, 0, STM32_PAGE_SIZE);

                    W25Q64_Read(UpdateA.Updata_A_Buff, i * 1024 + UpdateA.Updata_A_from_W25Q64_Num * 64 * 1024, OTA_Info.FirmwareLen[UpdateA.Updata_A_from_W25Q64_Num] % 1024);

                    u1_printf("\r\n");
                    STM32_WriteFlash(STM32_A_START_ADDR + i * STM32_PAGE_SIZE, (u32*) UpdateA.Updata_A_Buff, (OTA_Info.FirmwareLen[UpdateA.Updata_A_from_W25Q64_Num] % 1024));   // 将A区写入片上Flash位置
                }
                if (UpdateA.Updata_A_from_W25Q64_Num == 0) {
                    // 更新完成，清除OTA标志位
                    OTA_Info.OTA_flag = 0;
                    AT24C02_WriteOTAInfo();
                }
                u1_printf("A区更新完成，马上重启系统！\r\n");
                delay_ms(100);
                NVIC_SystemReset();
            } else {
                u1_printf("待更新APP长度错误！\r\n");
                BootStateFlag &= ~(UPDATA_A_FLAG);
            }
        }
    };
}
